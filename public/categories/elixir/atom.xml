<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Articles about Elixir | Simone Web Design]]></title>
  <link href="https://www.simonewebdesign.it/categories/elixir/atom.xml" rel="self"/>
  <link href="https://www.simonewebdesign.it/"/>
  <updated>2021-06-11T20:24:10+01:00</updated>
  <id>https://www.simonewebdesign.it/</id>
  <author>
    <name><![CDATA[Simone Vittori]]></name>
    
  </author>

  
  <entry>
    <title type="html"><![CDATA[A Pipeable Logger]]></title>
    <link href="https://www.simonewebdesign.it/a-pipeable-logger/"/>
    <updated>2017-04-03T00:00:00+01:00</updated>
    <id>https://www.simonewebdesign.it/a-pipeable-logger</id>
    <content type="html"><![CDATA[<p>The Elixir Logger is pretty good. You can easily log anything with it, just call one of <code class="language-plaintext highlighter-rouge">debug</code>, <code class="language-plaintext highlighter-rouge">info</code>, <code class="language-plaintext highlighter-rouge">warn</code> or <code class="language-plaintext highlighter-rouge">error</code>. For example:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"something happened"</span><span class="p">)</span>
</code></pre></div></div>

<p>Turns into:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>12:34:56.789 [info]  something happened
</code></pre></div></div>

<p>Very nice. However, there are cases where you may want to, say, change some data structure, like update a map or a list, and then log the transition, <strong>without breaking the pipe</strong>. Example:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">my_function</span> <span class="k">do</span>
  <span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

  <span class="n">list</span>
  <span class="o">|&gt;</span> <span class="no">Logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"before insert: </span><span class="si">#{</span><span class="n">inspect</span> <span class="n">list</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">into</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
  <span class="o">|&gt;</span> <span class="no">Logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"after insert: </span><span class="si">#{</span><span class="n">inspect</span> <span class="n">list</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This doesn’t work for many reasons. First, we can’t refer to <code class="language-plaintext highlighter-rouge">list</code> that way. If we do, we will always be logging <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code>, because Elixir’s data structures are immutable.
Second, <code class="language-plaintext highlighter-rouge">Logger.*</code> functions return the <code class="language-plaintext highlighter-rouge">:ok</code> atom, which means you can’t use them in a pipe—unless that is what you want to return.</p>

<p>The solution to both issues is actually pretty straightforward: use a lambda!
A lambda is just an anonymous function. We can define it and call it right away. So the code above becomes:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">my_function</span> <span class="k">do</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
  <span class="o">|&gt;</span> <span class="p">(</span><span class="k">fn</span> <span class="n">list</span> <span class="o">-&gt;</span>
    <span class="no">Logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"before insert: </span><span class="si">#{</span><span class="n">inspect</span> <span class="n">list</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="n">list</span>
  <span class="k">end</span><span class="p">)</span><span class="o">.</span><span class="p">()</span>
  <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">into</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
  <span class="o">|&gt;</span> <span class="p">(</span><span class="k">fn</span> <span class="n">list</span> <span class="o">-&gt;</span>
    <span class="no">Logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"after insert: </span><span class="si">#{</span><span class="n">inspect</span> <span class="n">list</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="n">list</span>
  <span class="k">end</span><span class="p">)</span><span class="o">.</span><span class="p">()</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If we call this function, we get:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>12:34:56.789 [debug] before insert: [1, 2, 3]

12:34:56.823 [debug] after insert: [0, 1, 2, 3]
</code></pre></div></div>

<p>Great, exactly what we want! Except the syntax is horrible. But fear not, we can improve on it. How about we make a wrapper?</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">PipeableLogger</span> <span class="k">do</span>
  <span class="kn">require</span> <span class="no">Logger</span>

  <span class="k">def</span> <span class="n">debug</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">Logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">data</span>
  <span class="k">end</span>

  <span class="c1"># def warn, do: ...</span>
  <span class="c1"># def error, do: ...</span>
  <span class="c1"># def info, do: ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Let’s rewrite our function once again:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">my_function</span> <span class="k">do</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
  <span class="o">|&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="no">PipeableLogger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nv">&amp;1</span><span class="p">,</span> <span class="s2">"before insert: </span><span class="si">#{</span><span class="n">inspect</span> <span class="nv">&amp;1</span><span class="si">}</span><span class="s2">"</span><span class="p">))</span><span class="o">.</span><span class="p">()</span>
  <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">into</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
  <span class="o">|&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="no">PipeableLogger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nv">&amp;1</span><span class="p">,</span> <span class="s2">"after insert: </span><span class="si">#{</span><span class="n">inspect</span> <span class="nv">&amp;1</span><span class="si">}</span><span class="s2">"</span><span class="p">))</span><span class="o">.</span><span class="p">()</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Still not pretty though, as we still needed to wrap the function in a lambda. If we want to build a proper <code class="language-plaintext highlighter-rouge">Logger</code> wrapper, there are at least two different cases we may want to handle:</p>

<ol>
  <li>Logging a simple message (without any data);</li>
  <li>Logging the data we receive from the pipe, maybe also with a message.</li>
</ol>

<p>Here’s the improved version of <code class="language-plaintext highlighter-rouge">PipeableLogger</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">PipeableLogger</span> <span class="k">do</span>
  <span class="kn">require</span> <span class="no">Logger</span>

  <span class="k">def</span> <span class="n">debug</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">msg</span> <span class="p">\\</span> <span class="s2">""</span><span class="p">,</span> <span class="n">metadata</span> <span class="p">\\</span> <span class="p">[])</span>
  <span class="k">def</span> <span class="n">debug</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="ow">when</span> <span class="n">msg</span> <span class="o">==</span> <span class="s2">""</span><span class="p">,</span> <span class="k">do</span><span class="p">:</span> <span class="no">Logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
  <span class="k">def</span> <span class="n">debug</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">Logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
    <span class="n">data</span>
  <span class="k">end</span>

  <span class="c1"># def warn, do: ...</span>
  <span class="c1"># def error, do: ...</span>
  <span class="c1"># def info, do: ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Let’s use it:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">my_function</span> <span class="k">do</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
  <span class="o">|&gt;</span> <span class="no">PipeableLogger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"before insert"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">into</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
  <span class="o">|&gt;</span> <span class="no">PipeableLogger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"after insert"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Much, much simpler! The only problem now is, we’re logging just a message. What if we want to log the data? It’s a lambda all over again.</p>

<p>Here’s the final version I came up with:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">PipeableLogger</span> <span class="k">do</span>
  <span class="kn">require</span> <span class="no">Logger</span>

  <span class="k">def</span> <span class="n">debug</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">msg</span> <span class="p">\\</span> <span class="s2">""</span><span class="p">,</span> <span class="n">metadata</span> <span class="p">\\</span> <span class="p">[])</span>
  <span class="k">def</span> <span class="n">debug</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="ow">when</span> <span class="n">msg</span> <span class="o">==</span> <span class="s2">""</span><span class="p">,</span> <span class="k">do</span><span class="p">:</span> <span class="no">Logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
  <span class="k">def</span> <span class="n">debug</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_binary</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">Logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span> <span class="o">&lt;&gt;</span> <span class="n">data</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
    <span class="n">data</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="n">debug</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">Logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span> <span class="o">&lt;&gt;</span> <span class="n">inspect</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">metadata</span><span class="p">)</span>
    <span class="n">data</span>
  <span class="k">end</span>

  <span class="c1"># def warn, do: ...</span>
  <span class="c1"># def error, do: ...</span>
  <span class="c1"># def info, do: ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The assumption is that we always want to concatenate the data with the message, which is fair enough I think. Let’s see it in action:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">my_function</span> <span class="k">do</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
  <span class="o">|&gt;</span> <span class="no">PipeableLogger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"before insert: "</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">into</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
  <span class="o">|&gt;</span> <span class="no">PipeableLogger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"after insert: "</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">my_function</span><span class="p">()</span>

<span class="mi">12</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span><span class="mf">56.789</span> <span class="p">[</span><span class="n">debug</span><span class="p">]</span> <span class="n">before</span> <span class="ss">insert:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="mi">12</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span><span class="mf">56.789</span> <span class="p">[</span><span class="n">debug</span><span class="p">]</span> <span class="k">after</span> <span class="ss">insert:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<p>Now we can log the data with a message, all in a pipe and without a lambda! Nice!</p>

<hr />

<p>Summing up, I’m not convinced a <code class="language-plaintext highlighter-rouge">Logger</code> wrapper is the right way. This kinda goes against the blog post, but to be fair I think Elixir people tend to use pipes way too much (I’m guilty as well). So I wouldn’t probably wrap <code class="language-plaintext highlighter-rouge">Logger</code> in any project.</p>

<p>It’s also worth noting that <code class="language-plaintext highlighter-rouge">Logger</code> supports the concept of metadata, which basically means you can already attach any data you want. For example, if you put this in your <code class="language-plaintext highlighter-rouge">config.exs</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span> <span class="ss">:logger</span><span class="p">,</span> <span class="ss">:console</span><span class="p">,</span>
  <span class="ss">metadata:</span> <span class="p">[</span><span class="ss">:my_list</span><span class="p">]</span>
</code></pre></div></div>

<p>You can then call <code class="language-plaintext highlighter-rouge">Logger</code> like this:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span> <span class="kn">require</span> <span class="no">Logger</span>
<span class="no">Logger</span>

<span class="n">iex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">"Work done"</span><span class="p">,</span> <span class="ss">my_list:</span> <span class="n">inspect</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="mi">12</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span><span class="mf">56.789</span> <span class="n">my_list</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="n">info</span><span class="p">]</span>  <span class="no">Work</span> <span class="n">done</span>
<span class="ss">:ok</span>
</code></pre></div></div>

<p>Point is, you don’t need a wrapper if all you want is concatenate some data in the log message. You <em>do</em> need a wrapper though (or a lambda) if you want to use <code class="language-plaintext highlighter-rouge">Logger</code> in a pipe.</p>

<p>So how about this instead?</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">my_function</span> <span class="k">do</span>
  <span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
  <span class="no">Logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"before insert: </span><span class="si">#{</span><span class="n">inspect</span> <span class="n">list</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
  <span class="n">new_list</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">into</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="no">Logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"after insert: </span><span class="si">#{</span><span class="n">inspect</span> <span class="n">new_list</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p><strong>Simple is better</strong>. It’s fine to break that pipe every once in a while!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to get the AST of an Elixir program]]></title>
    <link href="https://www.simonewebdesign.it/how-to-get-the-ast-of-an-elixir-program/"/>
    <updated>2015-11-14T19:43:10+00:00</updated>
    <id>https://www.simonewebdesign.it/how-to-get-the-ast-of-an-elixir-program</id>
    <content type="html"><![CDATA[<p>Getting the <strong>AST</strong> (Abstract Syntax Tree) representation of an <strong>Elixir</strong> source is pretty simple.</p>

<p>Let’s say we want to get the <strong>AST of this file</strong>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/hello.ex</span>
<span class="k">defmodule</span> <span class="no">Hello</span> <span class="k">do</span>
  <span class="k">def</span> <span class="n">hi</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="s2">"Hello "</span> <span class="o">&lt;&gt;</span> <span class="n">name</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We can do it right away from <code class="language-plaintext highlighter-rouge">iex</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">iex</span>
<span class="no">Erlang</span><span class="o">/</span><span class="no">OTP</span> <span class="mi">18</span> <span class="p">[</span><span class="n">erts</span><span class="o">-</span><span class="mf">7.0</span><span class="p">]</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="p">[</span><span class="mi">64</span><span class="o">-</span><span class="n">bit</span><span class="p">]</span> <span class="p">[</span><span class="ss">smp:</span><span class="mi">8</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="p">[</span><span class="n">async</span><span class="o">-</span><span class="ss">threads:</span><span class="mi">10</span><span class="p">]</span> <span class="p">[</span><span class="n">kernel</span><span class="o">-</span><span class="ss">poll:</span><span class="no">false</span><span class="p">]</span>

<span class="no">Interactive</span> <span class="no">Elixir</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="n">press</span> <span class="no">Ctrl</span><span class="o">+</span><span class="no">C</span> <span class="n">to</span> <span class="k">exit</span> <span class="p">(</span><span class="n">type</span> <span class="n">h</span><span class="p">()</span> <span class="no">ENTER</span> <span class="n">for</span> <span class="n">help</span><span class="p">)</span>
<span class="n">iex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">ast</span><span class="p">}</span> <span class="o">=</span> <span class="no">Code</span><span class="o">.</span><span class="n">string_to_quoted</span><span class="p">(</span><span class="no">File</span><span class="o">.</span><span class="n">read!</span><span class="p">(</span><span class="s2">"lib/hello.ex"</span><span class="p">))</span>
<span class="p">{</span><span class="ss">:ok</span><span class="p">,</span>
 <span class="p">{</span><span class="ss">:defmodule</span><span class="p">,</span> <span class="p">[</span><span class="ss">line:</span> <span class="mi">1</span><span class="p">],</span>
  <span class="p">[{</span><span class="ss">:__aliases__</span><span class="p">,</span> <span class="p">[</span><span class="ss">counter:</span> <span class="mi">0</span><span class="p">,</span> <span class="ss">line:</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="ss">:Hello</span><span class="p">]},</span>
   <span class="p">[</span><span class="k">do</span><span class="p">:</span> <span class="p">{</span><span class="ss">:def</span><span class="p">,</span> <span class="p">[</span><span class="ss">line:</span> <span class="mi">3</span><span class="p">],</span>
     <span class="p">[{</span><span class="ss">:hi</span><span class="p">,</span> <span class="p">[</span><span class="ss">line:</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[{</span><span class="ss">:name</span><span class="p">,</span> <span class="p">[</span><span class="ss">line:</span> <span class="mi">3</span><span class="p">],</span> <span class="no">nil</span><span class="p">}]},</span>
      <span class="p">[</span><span class="k">do</span><span class="p">:</span> <span class="p">{{:</span><span class="o">.</span><span class="p">,</span> <span class="p">[</span><span class="ss">line:</span> <span class="mi">4</span><span class="p">],</span>
         <span class="p">[{</span><span class="ss">:__aliases__</span><span class="p">,</span> <span class="p">[</span><span class="ss">counter:</span> <span class="mi">0</span><span class="p">,</span> <span class="ss">line:</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="ss">:IO</span><span class="p">]},</span> <span class="ss">:puts</span><span class="p">]},</span> <span class="p">[</span><span class="ss">line:</span> <span class="mi">4</span><span class="p">],</span>
        <span class="p">[{</span><span class="ss">:&lt;&gt;</span><span class="p">,</span> <span class="p">[</span><span class="ss">line:</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="s2">"Hello "</span><span class="p">,</span> <span class="p">{</span><span class="ss">:name</span><span class="p">,</span> <span class="p">[</span><span class="ss">line:</span> <span class="mi">4</span><span class="p">],</span> <span class="no">nil</span><span class="p">}]}]}]]}]]}}</span>
</code></pre></div></div>

<p>In our case, the <code class="language-plaintext highlighter-rouge">ast</code> variable will contain the full AST of the source code.</p>

<p>In case you want to get the <strong>AST of a single line</strong>, it’s even simpler:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">"John"</span>
<span class="s2">"John"</span>

<span class="n">iex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="s2">"Hello "</span> <span class="o">&lt;&gt;</span> <span class="n">name</span>
<span class="no">Hello</span> <span class="no">John</span>
<span class="ss">:ok</span>

<span class="n">iex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ast</span> <span class="o">=</span> <span class="kn">quote</span> <span class="k">do</span><span class="p">:</span> <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="s2">"Hello "</span> <span class="o">&lt;&gt;</span> <span class="n">name</span>
<span class="p">{{:</span><span class="o">.</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[{</span><span class="ss">:__aliases__</span><span class="p">,</span> <span class="p">[</span><span class="ss">alias:</span> <span class="no">false</span><span class="p">],</span> <span class="p">[</span><span class="ss">:IO</span><span class="p">]},</span> <span class="ss">:puts</span><span class="p">]},</span> <span class="p">[],</span>
 <span class="p">[{</span><span class="ss">:&lt;&gt;</span><span class="p">,</span> <span class="p">[</span><span class="ss">context:</span> <span class="no">Elixir</span><span class="p">,</span> <span class="kn">import</span><span class="p">:</span> <span class="no">Kernel</span><span class="p">],</span> <span class="p">[</span><span class="s2">"Hello "</span><span class="p">,</span> <span class="p">{</span><span class="ss">:name</span><span class="p">,</span> <span class="p">[],</span> <span class="no">Elixir</span><span class="p">}]}]}</span>
</code></pre></div></div>

<p>For more context, I recommend reading the <a href="https://elixir-lang.org/getting-started/meta/quote-and-unquote.html">introduction to meta-programming in Elixir</a> on Elixir’s official site.</p>

<p>In case you’re interested in <strong>parsing Elixir</strong>, <a href="https://andrealeopardi.com/posts/tokenizing-and-parsing-in-elixir-using-leex-and-yecc/">Tokenizing and parsing in Elixir with yecc and leex</a> by Andrea Leopardi is a very recommended reading.</p>

<p>Have fun with Elixir!</p>
]]></content>
  </entry>
  
</feed>
